#include "nexus/commands/build_command.h"
#include "nexus/utils/config_parser.h"
#include <iostream>
#include <fstream>
#include <filesystem>
#include <algorithm>

namespace fs = std::filesystem;

namespace nexus::commands {

int BuildCommand::execute() {
    fs::path toml_path = fs::current_path() / "nexus.toml";
    if (!fs::exists(toml_path)) {
        std::cerr << "nexus.toml not found in the current directory: " << fs::current_path() << std::endl;
        return 1;
    }

    std::cout << "Parsing nexus.toml file..." << std::endl;
    auto node_opt = nexus::utils::ConfigParser::parse_toml(toml_path.string());
    
    if (node_opt.has_value()) {
        std::cout << "Node name: " << node_opt->name << std::endl;
        std::cout << "Node version: " << node_opt->version.major << "." << node_opt->version.minor << "." << node_opt->version.patch << std::endl;

        std::cout << "Generating ninja file..." << std::endl;
        if (generate_ninja_file(*node_opt)) {
            std::cout << "Successfully generated build.ninja" << std::endl;
            return 0;
        } else {
            std::cerr << "Failed to generate build.ninja" << std::endl;
            return 1;
        }
    } else {
        std::cerr << "Failed to parse nexus.toml at: " << toml_path << std::endl;
        return 1;
    }
}

bool BuildCommand::generate_ninja_file(const nexus::core::Node& node) {
    fs::path ninja_path = fs::current_path() / "build.ninja";
    std::ofstream ninja_file(ninja_path);
    if (!ninja_file) {
        std::cerr << "Failed to open build.ninja for writing at: " << ninja_path << std::endl;
        return false;
    }

    ninja_file << "# ****** AUTOGENERATED ******\n";
    ninja_file << "# Ninja file for building " << node.name << "\n\n";

    // Compiler settings
    ninja_file << "# Compiler settings\n";
    ninja_file << "cxx = " << (node.toolchain.compiler.empty() ? "g++" : node.toolchain.compiler) << "\n";
    ninja_file << "cxxflags = -std=" << get_cpp_standard_flag(node.build_config.standard) 
               << " -Wall -Wextra -pedantic -I./include -I./external";

    // Add include paths for links
    for (const auto& [name, link] : node.links) {
        ninja_file << " -I./external/" << name << "/include";
    }
    ninja_file << "\n\n";

    // Rules
    ninja_file << "# Rules\n";
    ninja_file << "rule cxx\n";
    ninja_file << "  command = $cxx $cxxflags -c $in -o $out\n";
    ninja_file << "  description = Compiling $out\n\n";
    
    ninja_file << "rule link\n";
    ninja_file << "  command = $cxx $cxxflags $in -o $out\n";
    ninja_file << "  description = Linking $out\n\n";

    // Build statements
    ninja_file << "# Build statements\n";
    auto source_files = get_source_files();
    std::vector<std::string> object_files;

    for (const auto& src : source_files) {
        fs::path src_path(src);
        fs::path obj_path = fs::path("build") / "obj" / src_path.parent_path() / (src_path.stem().string() + ".o");
        std::string obj = obj_path.string();
        object_files.push_back(obj);
        ninja_file << "build " << obj << ": cxx " << src << "\n";
    }
    ninja_file << "\n";

    // Link
    ninja_file << "# Link\n";
    ninja_file << "build bin/" << node.name
#ifdef _WIN32
        << ".exe"
#endif
        << ": link";
    for (const auto& obj : object_files) {
        ninja_file << " $\n    " << obj;
    }
    ninja_file << "\n\n";

    // Default target
    ninja_file << "# Default target\n";
    ninja_file << "default bin/" << node.name
#ifdef _WIN32
        << ".exe"
#endif
        << "\n";

    ninja_file.close();
    std::cout << "Ninja file generation completed." << std::endl;
    return true;
}

std::vector<std::string> BuildCommand::get_source_files() {
    std::vector<std::string> sources;
    for (const auto& entry : fs::recursive_directory_iterator(fs::current_path() / "src")) {
        if (entry.path().extension() == ".cpp") {
            sources.push_back(fs::relative(entry.path(), fs::current_path()).string());
        }
    }
    return sources;
}

std::string BuildCommand::get_cpp_standard_flag(nexus::core::CppStandard standard) {
    switch (standard) {
        case nexus::core::CppStandard::Cpp11: return "c++11";
        case nexus::core::CppStandard::Cpp14: return "c++14";
        case nexus::core::CppStandard::Cpp17: return "c++17";
        case nexus::core::CppStandard::Cpp20: return "c++20";
        default: return "c++17"; // Default to C++17
    }
}

} // namespace nexus::commands
